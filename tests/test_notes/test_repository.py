"""Tests for the NoteRepository."""
import json
import os
import tempfile
from datetime import datetime
from typing import Generator
from unittest.mock import MagicMock, patch

import pytest

from ragaman.notes.model import Note
from ragaman.notes.repository import NoteRepository


@pytest.fixture
def mock_embedder() -> MagicMock:
    """Create a mock OpenAI embedder."""
    embedder = MagicMock()
    embedder.embed_text.return_value = [0.1, 0.2, 0.3]
    return embedder


@pytest.fixture
def temp_db_path() -> Generator[str, None, None]:
    """Create a temporary database file path."""
    fd, path = tempfile.mkstemp(suffix=".db")
    os.close(fd)
    yield path
    # Clean up
    if os.path.exists(path):
        os.unlink(path)


def test_repository_initialization(temp_db_path: str, mock_embedder: MagicMock) -> None:
    """Test repository initialization."""
    repo = NoteRepository(db_path=temp_db_path, embedder=mock_embedder)
    
    assert repo.db_path == temp_db_path
    assert repo.embedder == mock_embedder


def test_add_note_with_embedding(temp_db_path: str, mock_embedder: MagicMock) -> None:
    """Test adding a note with an existing embedding."""
    repo = NoteRepository(db_path=temp_db_path, embedder=mock_embedder)
    
    embedding = [0.5, 0.6, 0.7]
    note = Note(content="Test note", embedding=embedding)
    
    note_id = repo.add_note(note)
    
    # Verify note was added with the provided embedding
    assert note_id == 1
    saved_note = repo.get_note_by_id(note_id)
    assert saved_note is not None
    assert saved_note.content == "Test note"
    assert saved_note.embedding == embedding
    # Embedder should not have been called
    mock_embedder.embed_text.assert_not_called()


def test_add_note_without_embedding(temp_db_path: str, mock_embedder: MagicMock) -> None:
    """Test adding a note without an embedding."""
    repo = NoteRepository(db_path=temp_db_path, embedder=mock_embedder)
    
    note = Note(content="Test note without embedding")
    
    note_id = repo.add_note(note)
    
    # Verify note was added with an embedding generated by the embedder
    assert note_id == 1
    saved_note = repo.get_note_by_id(note_id)
    assert saved_note is not None
    assert saved_note.content == "Test note without embedding"
    assert saved_note.embedding == [0.1, 0.2, 0.3]
    # Embedder should have been called with the note content
    mock_embedder.embed_text.assert_called_once_with("Test note without embedding")


def test_get_all_notes(temp_db_path: str, mock_embedder: MagicMock) -> None:
    """Test retrieving all notes."""
    repo = NoteRepository(db_path=temp_db_path, embedder=mock_embedder)
    
    # Add some notes
    note1 = Note(content="Note 1")
    note2 = Note(content="Note 2")
    
    repo.add_note(note1)
    repo.add_note(note2)
    
    # Retrieve all notes
    notes = repo.get_all_notes()
    
    # Verify all notes were retrieved
    assert len(notes) == 2
    assert notes[0].content == "Note 1"
    assert notes[1].content == "Note 2"


def test_get_note_by_id(temp_db_path: str, mock_embedder: MagicMock) -> None:
    """Test retrieving a note by ID."""
    repo = NoteRepository(db_path=temp_db_path, embedder=mock_embedder)
    
    # Add a note
    note = Note(content="Test note")
    note_id = repo.add_note(note)
    
    # Retrieve the note by ID
    retrieved_note = repo.get_note_by_id(note_id)
    
    # Verify the note was retrieved correctly
    assert retrieved_note is not None
    assert retrieved_note.id == note_id
    assert retrieved_note.content == "Test note"


def test_get_note_by_id_not_found(temp_db_path: str, mock_embedder: MagicMock) -> None:
    """Test retrieving a non-existent note by ID."""
    repo = NoteRepository(db_path=temp_db_path, embedder=mock_embedder)
    
    # Retrieve a non-existent note
    retrieved_note = repo.get_note_by_id(999)
    
    # Verify no note was retrieved
    assert retrieved_note is None


def test_delete_note(temp_db_path: str, mock_embedder: MagicMock) -> None:
    """Test deleting a note."""
    repo = NoteRepository(db_path=temp_db_path, embedder=mock_embedder)
    
    # Add a note
    note = Note(content="Test note")
    note_id = repo.add_note(note)
    
    # Delete the note
    result = repo.delete_note(note_id)
    
    # Verify the note was deleted
    assert result is True
    assert repo.get_note_by_id(note_id) is None


def test_delete_note_not_found(temp_db_path: str, mock_embedder: MagicMock) -> None:
    """Test deleting a non-existent note."""
    repo = NoteRepository(db_path=temp_db_path, embedder=mock_embedder)
    
    # Delete a non-existent note
    result = repo.delete_note(999)
    
    # Verify the operation failed
    assert result is False


def test_search_similar(temp_db_path: str, mock_embedder: MagicMock) -> None:
    """Test searching for similar notes."""
    import numpy as np
    
    # Create a repository with a mock embedder
    repo = NoteRepository(db_path=temp_db_path, embedder=mock_embedder)
    
    # Add some notes with different embeddings
    note1 = Note(content="Note 1", embedding=[0.9, 0.1, 0.1])
    note2 = Note(content="Note 2", embedding=[0.1, 0.9, 0.1])
    note3 = Note(content="Note 3", embedding=[0.1, 0.1, 0.9])
    
    repo.add_note(note1)
    repo.add_note(note2)
    repo.add_note(note3)
    
    # Configure the embedder to return a specific embedding for the query
    query_embedding = [0.8, 0.1, 0.2]
    mock_embedder.embed_text.return_value = query_embedding
    
    # Search for similar notes
    results = repo.search_similar("test query", limit=2)
    
    # Verify the results
    assert len(results) == 2
    
    # Note 1 should be most similar to the query
    assert results[0][0].content == "Note 1"
    assert results[1][0].content == "Note 3"
    
    # Verify similarity scores
    # For Note 1: dot([0.8,0.1,0.2],[0.9,0.1,0.1]) / (norm([0.8,0.1,0.2]) * norm([0.9,0.1,0.1]))
    expected_similarity_1 = np.dot(query_embedding, [0.9, 0.1, 0.1]) / (
        np.linalg.norm(query_embedding) * np.linalg.norm([0.9, 0.1, 0.1])
    )
    assert results[0][1] == pytest.approx(expected_similarity_1)